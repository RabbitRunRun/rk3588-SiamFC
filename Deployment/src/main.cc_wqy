#include <iostream>
#include <cmath>
#include <climits>
#include <array>
#include <vector>

#include "seeta_aip.h"
#include "seeta_aip_opencv.h"
#include "seeta_aip_image_io.h"
//#include "seeta_aip_affine.h"
//#include "seeta_aip_plot.h"
//#include "seeta_aip_plot_text.h"

#include "cann.h"
#include "utils.h"
#include "anchors.h"

#include "resize_bicubic.h"


/////////////////////
#include "RgaUtils.h"
#include "im2d.h"
#include "opencv2/core/core.hpp"
#include "opencv2/imgcodecs.hpp"
#include "opencv2/imgproc.hpp"
#include "opencv2/highgui/highgui.hpp"

//#include "postprocess.h"
#include "rga.h"
#include "rknn_api.h"

#define PERF_WITH_POST 1


#define PI 3.1415926
const int g_anchor_num = 5;
const float PENALTY_K = 0.04;
const float WINDOW_INFLUENCE = 0.44;
const float LR = 0.33;

std::vector<float> g_window;
std::array<int,2> g_size;
uint8_t g_channel_average[3] = {0,0,0};
std::array<int, 2> g_center_pos;


std::array<int, 2> g_template_size = {127,127};
std::array<int, 2> g_search_size = {255,255};
std::array<int, 2> g_output_size = {(g_search_size[0]-g_template_size[0]) / 8 + 1, (g_search_size[1] - g_template_size[1]) / 8 + 1};

ACLTensor g_anchors;

double g_scale_z = 0.0;
double g_s_x = 0.0;
////////////////////////////////
static std::vector<float> CreateHannWindow(int num)
{
     std::vector<float> v;
     v.resize(num);
     for(int i=0; i<num; i++)
     {
          v[i] = 0.5 - 0.5 * cos(2 * PI * i / (num -1));
     }
     return v;
}


template<typename T>
static std::vector<T> outer(const std::vector<T>& a, const std::vector<T>& b)
{
    std::vector<T> result(a.size() * b.size());
    for(int i=0; i<a.size(); i++ )
    {
        for(int k=0; k<b.size(); k++)
        {
            result[i * b.size() + k] = b[k] * a[i];
            std::cout << "i:" << i << ", k:" << k << ",index:" << i * b.size() + k << ",s:" << b[k] * a[i] << std::endl;
        }
    }
    //std::partial_sum(b.begin(), b.end(), result.begin(), std::multiplies<T>());
    return result;
}


template<typename T>
static std::vector<T> tile(const std::vector<T> & a, unsigned int num)
{
    std::vector<T> res;
    res.resize(a.size() * num);
    for(int i=0; i<num; i++)
    {
        memcpy(res.data() + i * a.size(), a.data(), a.size() * sizeof(T));
    }
    return res;
}
////////////////////////////////




static ACLTensor generate_anchor(const std::array<int, 2> &score_size) {
    Anchors anchors(8, {0.33, 0.5, 1, 2, 3}, {8});
    /**
     * anchor = anchors.anchors
     * x1, y1, x2, y2 = anchor[:, 0], anchor[:, 1], anchor[:, 2], anchor[:, 3]
     * anchor = np.stack([(x1 + x2) * 0.5, (y1 + y2) * 0.5, x2 - x1, y2 - y1], 1)
     */
    ACLTensor anchor(anchors.anchors.shape());  // .shape = [len(scales) * len(ratios), 4];
    {
        auto src = anchors.anchors.data();
        auto dst = anchor.data();
        auto n = anchor.shape(0);
        for (decltype(n) i = 0; i < n; ++i) {
            auto x1 = src[0], y1 = src[1], x2 = src[2], y2 = src[3];

            dst[0] = (x1 + x2) * 0.5f;
            dst[1] = (y1 + y2) * 0.5f;
            dst[2] = x2 - x1;
            dst[3] = y2 - y1;

            src += 4;
            dst += 4;
        }
    }
    /**
     * total_stride = anchors.stride
     * anchor_num = anchor.shape[0]
     */
    auto total_stride = anchors.stride;
    auto anchor_num = anchor.shape(0);
    /**
     * anchor = np.tile(anchor, score_size[0] * score_size[1]).reshape((-1, 4))
     */
    {
        auto m = anchor_num;
        auto n = score_size[0] * score_size[1];
        ACLTensor tile_anchor(std::vector<int64_t>({m * n, 4}));
        auto src = anchor.data();
        auto dst = tile_anchor.data();
        for (decltype(m) i = 0; i < m; ++i) {
            for (decltype(n) j = 0; j < n; ++j) {
                dst[0] = src[0];
                dst[1] = src[1];
                dst[2] = src[2];
                dst[3] = src[3];

                dst += 4;
            }
            src += 4;
        }
        anchor = std::move(tile_anchor);
    }   // anchor.shape = [len(scales) * len(ratios) * score_size[0] * score_size[1], 4]
    /**
     * orix = - (score_size[0] / 2.) * total_stride
     * oriy = - (score_size[1] / 2.) * total_stride
     */
    auto orix = - (score_size[0] / 2.0f) * total_stride;
    auto oriy = - (score_size[1] / 2.0f) * total_stride;
    /**
     * xx, yy = np.meshgrid([orix + total_stride * dx for dx in range(score_size[0])],
     *                      [oriy + total_stride * dy for dy in range(score_size[1])])
     * xx, yy = np.tile(xx.flatten(), (anchor_num, 1)).flatten(), \
     *          np.tile(yy.flatten(), (anchor_num, 1)).flatten()
     * anchor[:, 0], anchor[:, 1] = xx.astype(np.float32), yy.astype(np.float32)
     */
    {
        std::vector<float> x(score_size[0]); 
        std::vector<float> y(score_size[1]);
        for (size_t i = 0; i < x.size(); ++i) x[i] = orix + total_stride * i;
        for (size_t i = 0; i < y.size(); ++i) y[i] = oriy + total_stride * i;

        {
            auto n = anchor.shape(0);
            auto dst = &anchor.at(0, 0);
            auto xs = decltype(n)(x.size());
            for (decltype(n) i = 0; i < n; ++i) {
                *dst = x[i % xs];
                dst += 4;
            }
        }
        {
            auto n = anchor.shape(0);
            auto dst = &anchor.at(0, 1);
            auto xs = decltype(n)(x.size());
            auto ys = decltype(n)(y.size());
            for (decltype(n) i = 0; i < n; ++i) {
                *dst = y[(i / xs) % ys];
                dst += 4;
            }
        }
    }
    return anchor;
}

static float image_scale(SeetaAIPImageData img, const std::array<int, 2> &size) {
    auto h = float(img.height);
    auto w = float(img.width);
    auto s0 = float(size[0]);
    auto s1 = float(size[1]);

    auto scale = (h / w < s1 / s0) ? (s0 / w) : (s1 / h);
    return scale;
}

static void fill_padding(
        SeetaAIPImageData img, const uint8_t (&color)[3],
        int x0, int x1, int y0, int y1) {
    auto w = int(img.width);
    auto h = int(img.height);
    struct Pixel { uint8_t rgb[3]; };
    auto c = (Pixel*)(&color[0]);
    {
        // top
        auto size = y0 * w;
        auto p = (Pixel*)img.data;
        for (int i = 0; i < size; ++i) {
            *p = *c;
            ++p;
        }
    }
    {
        // bottom
        auto size = (h - y1) * w;
        auto p = (Pixel*)img.data + y1 * w;
        for (int i = 0; i < size; ++i) {
            *p = *c;
            ++p;
        }
    }
    {
        // left
        auto step = x0;
        if (step) {
            auto size = y1 - y0;
            auto p = (Pixel*)img.data + y0 * w;
            auto jump = w - step;
            for (int i = 0; i < size; ++i) {
                for (int j = 0; j < step; ++j) {
                    *p = *c;
                    ++p;
                }
                p += jump;
            }
        }
    }
    {
        // right
        auto step = w - x1;
        if (step) {
            auto size = y1 - y0;
            auto p = (Pixel*)img.data + y0 * w + x1;
            auto jump = w - step;
            for (int i = 0; i < size; ++i) {
                for (int j = 0; j < step; ++j) {
                    *p = *c;
                    ++p;
                }
                p += jump;
            }
        }
    }
}

/*
static seeta::aip::ImageData resize_pad(
        SeetaAIPImageData img, const std::array<int, 2> &size, float scale,
        const uint8_t (&color)[3],    
        float *ptop = nullptr, float *pleft = nullptr) {
    auto width = int(img.width * scale);
    auto height = int(img.height * scale);
    auto top    = (size[1] - height) / 2;
    auto bottom = (size[1] - height) - top;
    auto left   = (size[0] - width) / 2;
    auto right  = (size[0] - width) - left;

    float m[9] = {
            1 / scale, 0, -left / scale,
            0, 1 / scale, -top / scale,
            0, 0, 1
    };

    auto result = seeta::aip::affine_sample2d(1, m, img, 0, 0, size[0], size[1]);

    fill_padding(result, color, left, left + width, top, top + height);

    if (ptop) *ptop = top;
    if (pleft) *pleft = left;

    return result;
}
*/

const SeetaAIPImageData image_pad(const SeetaAIPImageData& img, int left, int right, int top,int bottom, uint8_t(&c)[3])
{
        SeetaAIPImageData res;
        res.format = img.format;
        res.width = img.width + left + right;
        res.height = img.height + top + bottom;
        res.channels = img.channels;

        res.data = new unsigned char[res.width * res.height * res.channels];
        memset(res.data, 0, res.width * res.height * res.channels);

        // pad image
        //Image result(img.width() + 2 * w, img.height() + 2 * h, img.channels());
        //memset(result.data(), 0, result.count() * sizeof(Image::Datum));

        const unsigned char *iter_in_ptr = (const unsigned char *)img.data;
        int iter_in_step = img.width * img.channels;
        int copy_size = img.width * img.channels;
        int iter_size = img.height;
        unsigned char *iter_out_ptr = (unsigned char *)res.data + top * res.width * res.channels + left * res.channels;
        int iter_out_step = res.width * res.channels;

        for (int i = 0; i < iter_size; ++i, iter_in_ptr += iter_in_step, iter_out_ptr += iter_out_step)
        {
                memcpy(iter_out_ptr, iter_in_ptr, copy_size);
        }


        fill_padding(res, c, left, right, top,bottom);
        return res;
}

static SeetaAIPImageData image_crop(const SeetaAIPImageData& img, const Rect& rect)
{
        using namespace std;
        // Adjust rect
        Rect fixed_rect = rect;
        fixed_rect.w += fixed_rect.x;
        fixed_rect.h += fixed_rect.y;
        float tmpx = float(img.width - 1);
        fixed_rect.x = std::max<float>(0.0, std::min(tmpx, fixed_rect.x));

        float tmpy = float(img.height - 1);
        fixed_rect.y = std::max<float>(0.0, std::min(tmpy, fixed_rect.y));
        fixed_rect.w = std::max<float>(0.0, std::min(tmpx, fixed_rect.w));
        fixed_rect.h = std::max<float>(0.0, std::min(tmpy, fixed_rect.h));
        fixed_rect.w -= fixed_rect.x;
        fixed_rect.h -= fixed_rect.y;

        SeetaAIPImageData res;
        res.format = img.format;
        res.width = rect.w;
        res.height = rect.h;
        res.channels = img.channels;

        res.data = new unsigned char[res.width * res.height * res.channels];
        memset(res.data, 0, res.width * res.height * res.channels);

        const unsigned char *iter_in_ptr = (const unsigned char *)(img.data) + (int)(fixed_rect.y * img.width * img.channels + fixed_rect.x * img.channels);
        int iter_in_step = img.width * img.channels;
        int copy_size = int(fixed_rect.w * img.channels);
        int iter_size = int(fixed_rect.h);
        unsigned char *iter_out_ptr = (unsigned char *)res.data + std::max<int>(0, int(fixed_rect.y - rect.y)) * res.width * res.channels + std::max(0, int(fixed_rect.x - rect.x)) * res.channels;
        int iter_out_step = res.width * res.channels;

        for (int i = 0; i < iter_size; ++i, iter_in_ptr += iter_in_step, iter_out_ptr += iter_out_step)
        {
                memcpy(iter_out_ptr, iter_in_ptr, copy_size);
        }

        return res;
}



static void mean(SeetaAIPImageData img, uint8_t (&c)[3]) {
    double sum[3] = {0, 0, 0};
    auto n = img.width * img.height;
    auto p = (uint8_t*)img.data;
    for (decltype(n) i = 0; i < n; ++i) {
        sum[0] += p[0];
        sum[1] += p[1];
        sum[2] += p[2];
        p += 3;
    }
    c[0] = uint8_t(sum[0] / n);
    c[1] = uint8_t(sum[1] / n);
    c[2] = uint8_t(sum[2] / n);
}

/*
static void preprocess_image(
        SeetaAIPImageData timg, SeetaAIPImageData simg,
        const std::array<int, 2> &tsize, const std::array<int, 2> &ssize,
        float *pscale, float *pspad_top, float *pspad_left,
        seeta::aip::ImageData *ptimg, seeta::aip::ImageData *psimg) {
    using std::min;
    auto tscale = image_scale(timg, tsize);
    auto sscale = image_scale(simg, ssize);
    auto scale = tscale < 1 || sscale < 1 ? min(min(tscale, 1.0f), min(sscale, 1.0f)) : 1.0f;

    uint8_t tcolor[3] = {0, 0, 0};
    uint8_t scolor[3] = {0, 0, 0};
    mean(timg, tcolor);
    mean(simg, scolor);

    float spad_top, spad_left;
    auto padded_timg = resize_pad(timg, tsize, scale, tcolor);
    auto padded_simg = resize_pad(simg, ssize, scale, scolor, &spad_top, &spad_left);

    if (pscale) *pscale = scale;
    if (pspad_top) *pspad_top = spad_top;
    if (pspad_left) *pspad_left = spad_left;
    if (ptimg) *ptimg = padded_timg;
    if (psimg) *psimg = padded_simg;
}
*/

static ACLTensor preprocess(SeetaAIPImageData image) {
    // convert to RGB + NCHW format
    auto want_format = SEETA_AIP_FORMAT_CHW_U8BGR;
    seeta::aip::ImageData bgr_nchw;
    if (image.format != want_format) {
        bgr_nchw = seeta::aip::convert(1, want_format, image);
        image = bgr_nchw;
    }
    ACLTensor data(std::vector<int64_t>({1, image.channels, image.height, image.width}));
    auto HWC = image.height * image.width * image.channels;
    auto src = (const uint8_t*)image.data;
    auto dst = (float *)data.data();
    for (decltype(HWC) i = 0; i < HWC; ++i) {
        *dst = float(*src);
        ++src;
        ++dst;
    }
    return data;
}

static float softmax(float a, float b) {
    /**
     * tmp = np.max(x, axis=1)
     * x -= tmp.reshape((x.shape[0], 1))
     * x = np.exp(x)
     * tmp = np.sum(x, axis=1)
     * x /= tmp.reshape((x.shape[0], 1))
     */
    auto max = std::max(a, b);
    a -= max;
    b -= max;
    a = std::exp(a);
    b = std::exp(b);
    auto sum = a + b;
    return b / sum; // get [:, 1] at outside
}

static ACLTensor convert_score(const ACLTensor &output) {
    // output.shape = [1, 10, 105, 105]
    /**
     * score = score.transpose(1, 2, 3, 0).reshape(2, -1).transpose(1, 0)
     * score = softmax(score)[:, 1]
     */
    auto n = output.count() / 2;
    ACLTensor score(std::vector<int64_t>({n}));
    auto pa = output.data();
    auto pb = pa + n;
    auto pc = score.data();
    for (decltype(n) i = 0; i < n; ++i) {
        *pc++ = softmax(*pa++, *pb++);
    }
    return score;
}

static int64_t argmax(const ACLTensor &x) {
    auto p = x.data();
    auto n = x.count();
    auto maxv = p[0];
    decltype(n) maxi = 0;
    for (decltype(n) i = 1; i < n; ++i) {
        if (p[i] > maxv) {
            maxi = i;
            maxv = p[i];
        }
    }
    return maxi;
}

/**
 * decode single bbox at i
 */
static Rect decode_bbox(const ACLTensor &output, const ACLTensor &anchor, int64_t i) {
    // output.shape = [1, 20, 105, 105]
    /**
     * delta = delta.transpose(1, 2, 3, 0).reshape(4, -1)
     * delta[0, :] = delta[0, :] * anchor[:, 2] + anchor[:, 0]
     * delta[1, :] = delta[1, :] * anchor[:, 3] + anchor[:, 1]
     * delta[2, :] = np.exp(delta[2, :]) * anchor[:, 2]
     * delta[3, :] = np.exp(delta[3, :]) * anchor[:, 3]
     */
    auto n = output.count() / 4;
    
    auto p = &output.at(i);
    auto q = &anchor.at(i, 0);
    auto d0 = p[0];
    auto d1 = p[n];
    auto d2 = p[n * 2];
    auto d3 = p[n * 3];
    auto a0 = q[0];
    auto a1 = q[1];
    auto a2 = q[2];
    auto a3 = q[3];

    auto x = d0 * a2 + a0;
    auto y = d1 * a3 + a1;
    auto w = std::exp(d2) * a2;
    auto h = std::exp(d3) * a3;

    return {x, y, w, h};
}

void convert_bbox(ACLTensor &output, const ACLTensor &anchor)
{
    int ncol = output.count() / 4;
    for(int i=0; i<ncol; i++)
    {
              output.at(i)  = output.at(i) * anchor.at(i,2) + anchor.at(i,0);
              output.at(ncol + i) = output.at(ncol+i) * anchor.at(i,3) + anchor.at(i,1);
              output.at(2 * ncol + i) = std::exp(output.at(2 * ncol + i) * anchor.at(i,2));
              output.at(3 * ncol + i) = std::exp(output.at(3 * ncol + i) * anchor.at(i,3));
    }
}

ACLTensor change(const ACLTensor &output)
{
    ACLTensor res(output.shape());
    for(int i=0; i<output.count(); i++)
    {
          res.at(i) = std::max<float>(output.at(i), 1.0 / output.at(i));
    }
    return res;
}

ACLTensor change2(float * width_data, float * height_data, int len)
{
    std::vector<int64_t> dims;
    dims.push_back(len);
    ACLTensor res(dims);
    for(int i=0; i<res.count(); i++)
    {
          float value = (g_size[0] / g_size[1]) / (width_data[i] / height_data[i]);
          res.at(i) = std::max<float>(value, 1.0 / value);
    }
    return res;
}

ACLTensor sz(float *width_data, float * height_data, float scale, int len)
{
    std::vector<int64_t> dims;
    dims.push_back(len);
    ACLTensor res(dims);
    for(int i=0; i<len; i++)
    {
          float value = (width_data[i] + height_data[i] ) * 0.5;
          res.at(i) = std::sqrt((width_data[i] + value)  *  (height_data[i] + value));
          res.at(i) = res.at(i) / scale;
    }
    return res;
}

void bbox_clip(float & cx, float & cy, float &width, float & height, int image_width, int image_height)
{
    cx = std::max<float>(0.0, std::min<float>(cx, image_width));
    cy = std::max<float>(0.0, std::min<float>(cy, image_height));
    width = std::max<float>(10.0, std::min<float>(width, image_width));
    height = std::max<float>(10.0, std::min<float>(height, image_height));
}


struct ScoreRect {
    float score;
    Rect rect;
};

static ScoreRect postprocess(
        const ACLTensor &output_score, 
        const ACLTensor &output_bbox,
        const ACLTensor &anchors,
        const cv::Mat &mat
        /*
        const std::array<int, 2> &search_size,
        float sscale, float sleft, float stop */) {
    ACLTensor score = convert_score(output_score);

    ACLTensor pred_bbox(output_bbox.shape());
    memcpy(pred_bbox.data(), output_bbox.data(), output_bbox.bytes());


    convert_bbox(pred_bbox, anchors);

    int cols = pred_bbox.count() / 4;

    float tmp_w = g_size[0] * g_scale_z;
    float tmp_h = g_size[1] * g_scale_z;
    float tmp_pad = (tmp_w + tmp_h) * 0.5;
    float tmp_sz = std::sqrt((tmp_w + tmp_pad) * (tmp_h + tmp_pad));

    ACLTensor s_c = change(sz(pred_bbox.data() + 2 * cols, pred_bbox.data() + 3 * cols, tmp_sz, cols));

    ACLTensor r_c = change2(pred_bbox.data() + 2 * cols, pred_bbox.data() + 3 * cols, cols);

    ACLTensor penalty(r_c.shape());
    for(int i=0; i<r_c.count(); i++)
    {
        penalty.at(i) = std::exp(-(r_c.at(i) * s_c.at(i) - 1) * PENALTY_K); 
    }

    ACLTensor pscore(score.shape());
    for(int i=0; i<pscore.count(); i++)
    {
        pscore.at(i) = score.at(i) * penalty.at(i); 
        pscore.at(i) = pscore.at(i) * (1 - WINDOW_INFLUENCE) + g_window[i] * WINDOW_INFLUENCE;
    }

    auto best_idx = argmax(pscore);

    std::array<float, 4> bbox;
    for (int i=0; i< 4; i++)
    {
          bbox[i] = pred_bbox.at(i, best_idx) / g_scale_z;
    } 

    float lr = penalty.at(best_idx) * score.at(best_idx) * LR;

    float cx = bbox[0] + g_center_pos[0];
    float cy = bbox[1] + g_center_pos[1];
    float width = g_size[0] * (1 - lr) + bbox[2] * lr;
    float height = g_size[1] * (1 - lr) + bbox[3] * lr;

    bbox_clip(cx, cy, width, height, mat.cols, mat.rows);

    g_center_pos[0] = cx;
    g_center_pos[1] = cy;

    g_size[0] = width;
    g_size[1] = height;

     
    //auto best_score = score.at(best_idx);

    ScoreRect result;
    result.score = score.at(best_idx);
    result.rect.x = cx - width / 2;
    result.rect.y = cy - height / 2;
    result.rect.w = width;
    result.rect.h = height;
    return result;
    /*
    auto bbox = decode_bbox(output_bbox, anchors, best_idx);
    auto cx = bbox.x + search_size[0] / 2.0f;
    auto cy = bbox.y + search_size[1] / 2.0f;
    auto width = bbox.w;
    auto height = bbox.h;

    cx     = std::min<float>(std::max<float>(cx,      0), search_size[0]);
    cy     = std::min<float>(std::max<float>(cy,      0), search_size[1]);
    width  = std::min<float>(std::max<float>(width,  10), search_size[0]);
    height = std::min<float>(std::max<float>(height, 10), search_size[1]);

    cx -= sleft;
    cy -= stop;
    cx /= sscale;
    cy /= sscale;
    width /= sscale;
    height /= sscale;

    bbox.x = cx - width / 2;
    bbox.y = cy - height / 2;
    bbox.w = width;
    bbox.h = height;
    */
    //return { best_score, bbox };
}

std::ostream &operator<<(std::ostream &out, const ACLTensor &t) {
    std::ostringstream oss;
    oss << "float[";
    for (size_t i = 0; i < t.dims().size(); ++i) {
        if (i) oss << ", ";
        oss << t.dim(i);
    }
    oss << "]";
    return out << oss.str();
}



static ACLTensor get_subwindow(SeetaAIPImageData &img, std::array<int,2> &pos, int model_sz, int original_sz, uint8_t (&c)[3])
{
     float value = (original_sz + 1) / 2;
     float context_xmin = floor(pos[0] - value + 0.5);
     float context_xmax = context_xmin + original_sz -1;
     float context_ymin = floor(pos[1] - value + 0.5);
     float context_ymax = context_ymin + original_sz -1;

     int left_pad = int(std::max<float>(0.0, -context_xmin));
     int top_pad = int(std::max<float>(0.0, -context_ymin)); 
     int right_pad = int(std::max<float>(0.0, context_xmax - img.width + 1));
     int bottom_pad = int(std::max<float>(0.0, context_ymax - img.height + 1));

     context_xmin = context_xmin + left_pad;
     context_xmax = context_xmax + left_pad;
     context_ymin = context_ymin + top_pad;
     context_ymax = context_ymax + top_pad;

     Rect rect;
     rect.x = int(context_xmin);
     rect.y = int(context_ymin);   //int(context_xmax + 1);
     rect.w = int(context_xmax + 1) - rect.x;
     rect.h = int(context_ymax + 1) - rect.y;
     SeetaAIPImageData res;
     if (left_pad > 0 || top_pad > 0 || right_pad > 0 || bottom_pad > 0)
     {
          SeetaAIPImageData imagepad = image_pad(img, left_pad, right_pad, top_pad, bottom_pad, c);
          res = image_crop(imagepad, rect);// int(context_xmin),  int(context_xmax + 1), int(context_ymin), int(context_ymax + 1));
          delete [] imagepad.data;

     }else
     {
          res = image_crop(img, rect);//int(context_xmin),  int(context_xmax + 1), int(context_ymin), int(context_ymax + 1));
     }

     ACLTensor ten;
     if (model_sz != original_sz)
     {
          SeetaAIPImageData s;
          s.format = res.format;
          s.width = model_sz;
          s.height = model_sz;
          s.channels = res.channels;

          s.data = new unsigned char[s.width * s.height * s.channels];
          memset(s.data, 0, s.width * s.height * s.channels);
          resize_bicubic<uint8_t>((const unsigned char *)res.data,res.width,res.height,res.channels, (unsigned char *)s.data,s.width,s.height);

          //delete [] res.data; 
          ten = preprocess(s);
          delete [] s.data; 
     }else 
     {
          ten = preprocess(res);    
          //return res;
     }

     delete [] res.data; 
     return ten;
}


/*
int main() {
    std::string om_file_path = "../data/checkpoint_e50.om";
    std::string template_image_path = "../demo/tar34.jpg";
    std::string search_image_path = "../demo/bg34.jpg";
    
    std::string output_path = "./result.jpg";

    // following sizes associated with the network input size
    std::array<int, 2> template_size = {127, 127};
    std::array<int, 2> search_size = {895, 895};

    // Do not release this object during model usage.
    ACLDeviceContext ctx;
    
    std::array<int, 2> output_size = {
            (search_size[0] - template_size[0]) / 8 + 1 + 8,
            (search_size[1] - template_size[1]) / 8 + 1 + 8
    };

    auto anchors = generate_anchor(output_size);
    
    ACLModel model(om_file_path);

    auto template_image = seeta::aip::imread(template_image_path);
    auto search_image = seeta::aip::imread(search_image_path);

    if (!template_image.channels()) {
        std::cerr << "Can not access image " << template_image_path << std::endl;
        return 1;
    }
    if (!search_image.channels()) {
        std::cerr << "Can not access image " << search_image_path << std::endl;
        return 1;
    }

    std::cout << "load template " << template_image.width() << "x" << template_image.height() << std::endl;
    std::cout << "load search " << search_image.width() << "x" << search_image.height() << std::endl;

    float size_scale = 1;
    float spad_top = 0, spad_left = 0;
    seeta::aip::ImageData timg_tran, simg_tran;
    preprocess_image(
            template_image, search_image, template_size, search_size,
            &size_scale, &spad_top, &spad_left, &timg_tran, &simg_tran);

    auto input_template = preprocess(timg_tran);
    auto input_search = preprocess(simg_tran);
   
    std::cout << input_template << std::endl;
    std::cout << input_search << std::endl;

    model.set_input(0, input_template);
    model.set_input(1, input_search);

    model.run();

    auto output0 = model.get_output(0);
    auto output1 = model.get_output(1);

    auto score_bbox = postprocess(output0, output1, anchors, search_size, size_scale, spad_left, spad_top);

    std::cout << score_bbox.rect << ": " << score_bbox.score << std::endl;

    // render and write to file
    auto det_bbox = score_bbox.rect;
    seeta::aip::plot::rectangle(search_image,
        SeetaAIPPoint{det_bbox.x, det_bbox.y},
        SeetaAIPPoint{det_bbox.x + det_bbox.w, det_bbox.y + det_bbox.h},
        {0, 255, 0}, 2);

    auto text = "score: " + std::to_string(score_bbox.score);
    seeta::aip::plot::text(search_image, text, SeetaAIPPoint{5, 25}, seeta::aip::plot::Color(0, 255, 0), 1.0f);    

    seeta::aip::imwrite(output_path, search_image);

    return 0;
}
*/


///////////////////////
static void dump_tensor_attr(rknn_tensor_attr* attr)
{
  printf("  index=%d, name=%s, n_dims=%d, dims=[%d, %d, %d, %d], n_elems=%d, size=%d, fmt=%s, type=%s, qnt_type=%s, "
         "zp=%d, scale=%f\n",
         attr->index, attr->name, attr->n_dims, attr->dims[0], attr->dims[1], attr->dims[2], attr->dims[3],
         attr->n_elems, attr->size, get_format_string(attr->fmt), get_type_string(attr->type),
         get_qnt_type_string(attr->qnt_type), attr->zp, attr->scale);
}

double __get_us(struct timeval t) { return (t.tv_sec * 1000000 + t.tv_usec); }

static unsigned char* load_data(FILE* fp, size_t ofst, size_t sz)
{
  unsigned char* data;
  int            ret;

  data = NULL;

  if (NULL == fp) {
    return NULL;
  }

  ret = fseek(fp, ofst, SEEK_SET);
  if (ret != 0) {
    printf("blob seek failure.\n");
    return NULL;
  }

  data = (unsigned char*)malloc(sz);
  if (data == NULL) {
    printf("buffer malloc failure.\n");
    return NULL;
  }
  ret = fread(data, 1, sz, fp);
  return data;
}

static unsigned char* load_model(const char* filename, int* model_size)
{
  FILE*          fp;
  unsigned char* data;

  fp = fopen(filename, "rb");
  if (NULL == fp) {
    printf("Open file %s failed.\n", filename);
    return NULL;
  }

  fseek(fp, 0, SEEK_END);
  int size = ftell(fp);

  data = load_data(fp, 0, size);

  fclose(fp);

  *model_size = size;
  return data;
}

static int saveFloat(const char* file_name, float* output, int element_size)
{
  FILE* fp;
  fp = fopen(file_name, "w");
  for (int i = 0; i < element_size; i++) {
    fprintf(fp, "%.6f\n", output[i]);
  }
  fclose(fp);
  return 0;
}


static void init(rknn_context &ctx,rknn_input *inputs, int input_num,rknn_output *outputs, int output_num, cv::Mat &mat, cv::Rect bbox)
{
    g_center_pos[0] = bbox.x + (bbox.width -1) / 2;
    g_center_pos[1] = bbox.y + (bbox.height -1) / 2;
    g_size[0] = bbox.width;
    g_size[1] = bbox.height;

    int w_z = g_size[0] + 0.5 * (g_size[0] + g_size[1]);
    int h_z = g_size[1] + 0.5 * (g_size[0] + g_size[1]);

    double s_z = round(sqrt(w_z * h_z));
    g_scale_z = g_template_size[0] / s_z;
    g_s_x = s_z * (g_search_size[0] / g_template_size[0]);

    SeetaAIPImageData s;
    s.format = SEETA_AIP_FORMAT_U8BGR;//res.format;
    s.width = mat.cols;
    s.height = mat.rows;
    s.channels = mat.channels();
    s.data = mat.data;//new unsigned char[s.weight * s.height * s.channels];
    //memset(s.data, 0, s.weight * s.height * s.channels);
    mean(s, g_channel_average); 
    
    ACLTensor z_crop = get_subwindow(s, g_center_pos, g_template_size[0], s_z, g_channel_average); 
    inputs[0].buf = (void *)z_crop.data();
    rknn_inputs_set(ctx, input_num, inputs);
    int ret = rknn_run(ctx, NULL);
    if(ret != RKNN_SUCC)
    {
         printf("rknn_run failed, ret:%d\n",ret);
         exit(-1);
    }
    ret = rknn_outputs_get(ctx, output_num, outputs, NULL);
    if (ret != RKNN_SUCC)
    {
         printf("rknn_outputs_get failed, ret:%d\n",ret);
         exit(-1);
    }
    printf("init ok\n");
}


static ScoreRect track(rknn_context &ctx,rknn_tensor_attr *output_attr,rknn_input *inputs, int input_num,rknn_output *outputs, int output_num, cv::Mat &mat, rknn_output *pre_outputs, int pre_output_num)
{
    SeetaAIPImageData s;
    s.format = SEETA_AIP_FORMAT_U8BGR;//res.format;
    s.width = mat.cols;
    s.height = mat.rows;
    s.channels = mat.channels();
    s.data = mat.data;//new unsigned char[s.weight * s.height * s.channels];
    ACLTensor x_crop = get_subwindow(s, g_center_pos, g_search_size[0], round(g_s_x), g_channel_average); 

    inputs[0].buf = pre_outputs[0].buf;
    inputs[0].size = pre_outputs[0].size;
    inputs[1].buf = pre_outputs[1].buf; 
    inputs[1].size = pre_outputs[1].size;

    inputs[2].buf = pre_outputs[2].buf; 
    inputs[2].size = pre_outputs[2].size;

    inputs[3].buf = (void *)x_crop.data(); 
    inputs[3].size = x_crop.count();
    
    rknn_inputs_set(ctx, input_num, inputs);
    
    int ret = rknn_run(ctx, NULL);
    if(ret != RKNN_SUCC)
    {
         printf("rknn_run failed, ret:%d\n",ret);
         exit(-1);
    }
    ret = rknn_outputs_get(ctx, output_num, outputs, NULL);
    if (ret != RKNN_SUCC)
    {
         printf("rknn_outputs_get failed, ret:%d\n",ret);
         exit(-1);
    }
    printf("track ok\n");

    std::vector<int64_t> dims_0;
    for(int i=0; i<output_attr[0].n_dims; i++)
    {
         dims_0.push_back(output_attr[0].dims[i]);
    }

    std::vector<int64_t> dims_1;
    for(int i=0; i<output_attr[1].n_dims; i++)
    {
         dims_1.push_back(output_attr[1].dims[i]);
    }

    ACLTensor output0(dims_0);
    memcpy(output0.data(), outputs[0].buf, outputs[0].size);
 
    ACLTensor output1(dims_1);
    memcpy(output1.data(), outputs[1].buf, outputs[1].size);
    ScoreRect r = postprocess(output0, output1, g_anchors, mat);

    rknn_outputs_release(ctx, output_num, outputs);
    return r;
}

/*-------------------------------------------*/
int main(int argc, char** argv)
{
  int            status     = 0;
  char*          model_name = NULL;
  rknn_context   fctx;
  rknn_context   mctx;
  size_t         actual_size        = 0;
  int            img_width          = 0;
  int            img_height         = 0;
  int            img_channel        = 0;
  //const float    nms_threshold      = NMS_THRESH;
  //const float    box_conf_threshold = BOX_THRESH;
  struct timeval start_time, stop_time;
  int            ret;


  //std::array<int, 2> template_size = {127,127};
  //std::array<int, 2> search_size = {255,255};
  //std::array<int, 2> output_size = {(search_size[0]-template_size[0]) / 8 + 1, (search_size[1] - template_size[1]) / 8 + 1};
  if (g_template_size[0] < 160) 
  {
      g_output_size[0] = g_search_size[0] / 8 -7 + 1;
      g_output_size[1] = g_search_size[1] / 8 -7 + 1;
  }
  
  g_anchors = generate_anchor(g_output_size);

  std::vector<float> hanning = CreateHannWindow(g_output_size[0]);
  std::vector<float> outerwindow = outer(hanning, hanning);
  g_window = tile<float>(outerwindow, 5);  


  // init rga context
  rga_buffer_t src;
  rga_buffer_t dst;
  im_rect      src_rect;
  im_rect      dst_rect;
  memset(&src_rect, 0, sizeof(src_rect));
  memset(&dst_rect, 0, sizeof(dst_rect));
  memset(&src, 0, sizeof(src));
  memset(&dst, 0, sizeof(dst));

  if (argc != 3) {
    printf("Usage: %s <rknn model> <jpg> \n", argv[0]);
    return -1;
  }

  //printf("post process config: box_conf_threshold = %.2f, nms_threshold = %.2f\n", box_conf_threshold, nms_threshold);

  //model_name       = (char*)argv[1];
  //char* image_name = argv[2];

  //printf("Read %s ...\n", image_name);
  std::string video_name = "demo/20240426192512-01_cut.mp4";
  std::string fonnx_file_path = "models/checkpoint_e50_f.onnx";
  std::string monnx_file_path = "models/checkpoint_e50_m.onnx";

  /*
  cv::Mat orig_img = cv::imread(image_name, 1);
  if (!orig_img.data) {
    printf("cv::imread %s fail!\n", image_name);
    return -1;
  }
  cv::Mat img;
  cv::cvtColor(orig_img, img, cv::COLOR_BGR2RGB);
  img_width  = img.cols;
  img_height = img.rows;
  printf("img width = %d, img height = %d\n", img_width, img_height);
  */

  /* Create the neural network */
  printf("Loading mode...\n");
  int            fmodel_data_size = 0;
  unsigned char* fmodel_data      = load_model(fonnx_file_path.c_str(), &fmodel_data_size);
  ret                            = rknn_init(&fctx, fmodel_data, fmodel_data_size, 0, NULL);
  if (ret < 0) {
    printf("rknn_init :%s error ret=%d\n", fonnx_file_path.c_str(), ret);
    return -1;
  }

  int            mmodel_data_size = 0;
  unsigned char* mmodel_data      = load_model(monnx_file_path.c_str(), &mmodel_data_size);
  ret                            = rknn_init(&mctx, mmodel_data, mmodel_data_size, 0, NULL);
  if (ret < 0) {
    printf("rknn_init :%s error ret=%d\n", monnx_file_path.c_str(), ret);
    return -1;
  }

  rknn_sdk_version fversion;
  ret = rknn_query(fctx, RKNN_QUERY_SDK_VERSION, &fversion, sizeof(rknn_sdk_version));
  if (ret < 0) {
    printf("rknn_init error ret=%d\n", ret);
    return -1;
  }
  printf("sdk version: %s driver version: %s\n", fversion.api_version, fversion.drv_version);

  rknn_input_output_num f_io_num;
  ret = rknn_query(fctx, RKNN_QUERY_IN_OUT_NUM, &f_io_num, sizeof(f_io_num));
  if (ret < 0) {
    printf("rknn_init query input_output_num error ret=%d\n", ret);
    return -1;
  }
  printf("model input num: %d, output num: %d\n", f_io_num.n_input, f_io_num.n_output);

  rknn_tensor_attr f_input_attrs[f_io_num.n_input];
  memset(f_input_attrs, 0, sizeof(f_input_attrs));
  for (int i = 0; i < f_io_num.n_input; i++) {
    f_input_attrs[i].index = i;
    ret                  = rknn_query(fctx, RKNN_QUERY_INPUT_ATTR, &(f_input_attrs[i]), sizeof(rknn_tensor_attr));
    if (ret < 0) {
      printf("rknn_init query_input_attr error ret=%d\n", ret);
      return -1;
    }
    dump_tensor_attr(&(f_input_attrs[i]));
  }

  rknn_tensor_attr f_output_attrs[f_io_num.n_output];
  memset(f_output_attrs, 0, sizeof(f_output_attrs));
  for (int i = 0; i < f_io_num.n_output; i++) {
    f_output_attrs[i].index = i;
    ret                   = rknn_query(fctx, RKNN_QUERY_OUTPUT_ATTR, &(f_output_attrs[i]), sizeof(rknn_tensor_attr));
    dump_tensor_attr(&(f_output_attrs[i]));
  }

  int f_channel = 3;
  int f_width   = 0;
  int f_height  = 0;
  if (f_input_attrs[0].fmt == RKNN_TENSOR_NCHW) {
    printf("model is NCHW input fmt\n");
    f_channel = f_input_attrs[0].dims[1];
    f_height  = f_input_attrs[0].dims[2];
    f_width   = f_input_attrs[0].dims[3];
  } else {
    printf("model is NHWC input fmt\n");
    f_height  = f_input_attrs[0].dims[1];
    f_width   = f_input_attrs[0].dims[2];
    f_channel = f_input_attrs[0].dims[3];
  }

  printf("model input height=%d, width=%d, channel=%d\n", f_height, f_width, f_channel);

  /////////////////////////////////////////////
  rknn_sdk_version mversion;
  ret = rknn_query(mctx, RKNN_QUERY_SDK_VERSION, &mversion, sizeof(rknn_sdk_version));
  if (ret < 0) {
    printf("rknn_init error ret=%d\n", ret);
    return -1;
  }
  printf("m sdk version: %s driver version: %s\n", mversion.api_version, mversion.drv_version);

  rknn_input_output_num m_io_num;
  ret = rknn_query(mctx, RKNN_QUERY_IN_OUT_NUM, &m_io_num, sizeof(m_io_num));
  if (ret < 0) {
    printf("m rknn_init query input_output_num error ret=%d\n", ret);
    return -1;
  }
  printf("m model input num: %d, output num: %d\n", m_io_num.n_input, m_io_num.n_output);

  rknn_tensor_attr m_input_attrs[m_io_num.n_input];
  memset(m_input_attrs, 0, sizeof(m_input_attrs));
  for (int i = 0; i < m_io_num.n_input; i++) {
    m_input_attrs[i].index = i;
    ret                  = rknn_query(mctx, RKNN_QUERY_INPUT_ATTR, &(m_input_attrs[i]), sizeof(rknn_tensor_attr));
    if (ret < 0) {
      printf("m rknn_init query_input_attr error ret=%d\n", ret);
      return -1;
    }
    dump_tensor_attr(&(m_input_attrs[i]));
  }

  rknn_tensor_attr m_output_attrs[m_io_num.n_output];
  memset(m_output_attrs, 0, sizeof(m_output_attrs));
  for (int i = 0; i < m_io_num.n_output; i++) {
    m_output_attrs[i].index = i;
    ret                   = rknn_query(mctx, RKNN_QUERY_OUTPUT_ATTR, &(m_output_attrs[i]), sizeof(rknn_tensor_attr));
    dump_tensor_attr(&(m_output_attrs[i]));
  }

  int m_channel = 3;
  int m_width   = 0;
  int m_height  = 0;
  if (m_input_attrs[0].fmt == RKNN_TENSOR_NCHW) {
    printf("m model is NCHW input fmt\n");
    m_channel = m_input_attrs[0].dims[1];
    m_height  = m_input_attrs[0].dims[2];
    m_width   = m_input_attrs[0].dims[3];
  } else {
    printf("m model is NHWC input fmt\n");
    m_height  = m_input_attrs[0].dims[1];
    m_width   = m_input_attrs[0].dims[2];
    m_channel = m_input_attrs[0].dims[3];
  }

  printf("model input height=%d, width=%d, channel=%d\n", m_height, m_width, m_channel);

  ////////////////////////////////
  
  rknn_input f_inputs[1];
  memset(f_inputs, 0, sizeof(f_inputs));
  f_inputs[0].index        = 0;
  f_inputs[0].type         = f_input_attrs[0].type; //RKNN_TENSOR_UINT8;
  f_inputs[0].size         = f_width * f_height * f_channel;
  f_inputs[0].fmt          = f_input_attrs[0].fmt;//RKNN_TENSOR_NCHW;
  f_inputs[0].pass_through = 0;
  

  rknn_output f_outputs[f_io_num.n_output];
  memset(f_outputs, 0, sizeof(f_outputs));
  for (int i = 0; i < f_io_num.n_output; i++) 
  {
      f_outputs[i].want_float = 0;
  }


  rknn_input m_inputs[m_io_num.n_input];
  memset(m_inputs, 0, sizeof(m_inputs));
  for(int i=0; i<m_io_num.n_input; i++)
  {
      m_inputs[i].index        = i;
      m_inputs[i].type         = m_input_attrs[i].type; //RKNN_TENSOR_UINT8;
      //f_inputs[i].size         = f_width * f_height * f_channel;
      m_inputs[i].fmt          = m_input_attrs[i].fmt;//RKNN_TENSOR_NCHW;
      m_inputs[i].pass_through = 0;
  } 

  rknn_output m_outputs[m_io_num.n_output];
  memset(m_outputs, 0, sizeof(m_outputs));
  for (int i = 0; i < m_io_num.n_output; i++) 
  {
      m_outputs[i].want_float = 0;
  }
  //////////////////////////////
  cv::VideoCapture cap(video_name.c_str());
  int first_frame = 1;
  cv::Mat mat;
  while(1)
  {
      if(!cap->read(mat))
      {
          printf("read video fail\n");
          break;
      }
      if(first_frame)
      {
           first_frame = 0;
           cv::Rect init_rect;
           try
           {
                init_rect = cv::selectROI(video_name.c_str(), mat, false, false);
           }catch(std::exception &e)
           {
                printf("selectROI failed,%s\n",e.what());
                exit(-1);
           } 
           init(fctx, f_inputs,f_io_num.n_input, f_outputs, f_io_num.n_output, init_rect);
      }else 
      {
           ScoreRect r = track(mctx,m_output_attrs, m_inputs, m_io_num_n_input, m_outputs, m_io_num_n_output, mat, f_outputs, f_io_num.n_output);
           printf("best_score:%f\n",r.best_score);

           cv::rectangele(mat, int(r.rect.x), int(r.rect.y), int(r.rect.x + r.rect.w), int(r.rect.y + r.rect.h),(0,255,0),3);
           cv::imshow(video_name,frame);
           cv::waitkey(1);
      }

  }


  rknn_outputs_release(fctx, f_io_num.n_output, f_outputs);
  rknn_destroy(fctx);
  rknn_destroy(mctx);

  if (fmodel_data) {
    free(fmodel_data);
  }

  if (mmodel_data) {
    free(mmodel_data);
  }

  //////////////////////////////

  /*
  // You may not need resize when src resulotion equals to dst resulotion
  void* resize_buf = nullptr;

  if (img_width != width || img_height != height) {
    printf("resize with RGA!\n");
    resize_buf = malloc(height * width * channel);
    memset(resize_buf, 0x00, height * width * channel);

    src = wrapbuffer_virtualaddr((void*)img.data, img_width, img_height, RK_FORMAT_RGB_888);
    dst = wrapbuffer_virtualaddr((void*)resize_buf, width, height, RK_FORMAT_RGB_888);
    ret = imcheck(src, dst, src_rect, dst_rect);
    if (IM_STATUS_NOERROR != ret) {
      printf("%d, check error! %s", __LINE__, imStrError((IM_STATUS)ret));
      return -1;
    }
    IM_STATUS STATUS = imresize(src, dst);

    // for debug
    cv::Mat resize_img(cv::Size(width, height), CV_8UC3, resize_buf);
    cv::imwrite("resize_input.jpg", resize_img);

    inputs[0].buf = resize_buf;
  } else {
    inputs[0].buf = (void*)img.data;
  }

  gettimeofday(&start_time, NULL);
  rknn_inputs_set(ctx, io_num.n_input, inputs);

  rknn_output outputs[io_num.n_output];
  memset(outputs, 0, sizeof(outputs));
  for (int i = 0; i < io_num.n_output; i++) {
    outputs[i].want_float = 0;
  }

  ret = rknn_run(ctx, NULL);
  ret = rknn_outputs_get(ctx, io_num.n_output, outputs, NULL);
  gettimeofday(&stop_time, NULL);
  printf("once run use %f ms\n", (__get_us(stop_time) - __get_us(start_time)) / 1000);

  // post process
  float scale_w = (float)width / img_width;
  float scale_h = (float)height / img_height;

  detect_result_group_t detect_result_group;
  std::vector<float>    out_scales;
  std::vector<int32_t>  out_zps;
  for (int i = 0; i < io_num.n_output; ++i) {
    out_scales.push_back(output_attrs[i].scale);
    out_zps.push_back(output_attrs[i].zp);
  }
  post_process((int8_t*)outputs[0].buf, (int8_t*)outputs[1].buf, (int8_t*)outputs[2].buf, height, width,
               box_conf_threshold, nms_threshold, scale_w, scale_h, out_zps, out_scales, &detect_result_group);


  // Draw Objects
  char text[256];
  for (int i = 0; i < detect_result_group.count; i++) {
    detect_result_t* det_result = &(detect_result_group.results[i]);
    sprintf(text, "%s %.1f%%", det_result->name, det_result->prop * 100);
    printf("%s @ (%d %d %d %d) %f\n", det_result->name, det_result->box.left, det_result->box.top,
           det_result->box.right, det_result->box.bottom, det_result->prop);
    int x1 = det_result->box.left;
    int y1 = det_result->box.top;
    int x2 = det_result->box.right;
    int y2 = det_result->box.bottom;
    rectangle(orig_img, cv::Point(x1, y1), cv::Point(x2, y2), cv::Scalar(255, 0, 0, 255), 3);
    putText(orig_img, text, cv::Point(x1, y1 + 12), cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(0, 0, 0));
  }

  imwrite("./out.jpg", orig_img);
  ret = rknn_outputs_release(ctx, io_num.n_output, outputs);

  // loop test
  int test_count = 10;
  gettimeofday(&start_time, NULL);
  for (int i = 0; i < test_count; ++i) {
    rknn_inputs_set(ctx, io_num.n_input, inputs);
    ret = rknn_run(ctx, NULL);
    ret = rknn_outputs_get(ctx, io_num.n_output, outputs, NULL);
#if PERF_WITH_POST
    post_process((int8_t*)outputs[0].buf, (int8_t*)outputs[1].buf, (int8_t*)outputs[2].buf, height, width,
                 box_conf_threshold, nms_threshold, scale_w, scale_h, out_zps, out_scales, &detect_result_group);
#endif
    ret = rknn_outputs_release(ctx, io_num.n_output, outputs);
  }
  gettimeofday(&stop_time, NULL);
  printf("loop count = %d , average run  %f ms\n", test_count,
         (__get_us(stop_time) - __get_us(start_time)) / 1000.0 / test_count);

  deinitPostProcess();

  // release
  ret = rknn_destroy(ctx);

  if (model_data) {
    free(model_data);
  }

  if (resize_buf) {
    free(resize_buf);
  }
  */
  return 0;
}





